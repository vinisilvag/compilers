README file for Programming Assignment 3 (C++ edition)
======================================================

Your directory should now contain the following files:

 Makefile		  -> [course dir]/src/PA3/Makefile
 README
 cool.y
 bad.cl
 good.cl
 cool-tree.handcode.h
 cool-tree.cc		  -> [course dir]/src/PA3/cool-tree.cc
 cool-tree.aps		  -> [course dir]/src/PA3/cool-tree.aps
 dumptype.cc		  -> [course dir]/src/PA3/dumptype.cc
 handle_flags.c           -> [course dir]/src/PA3/handle_flags.cc
 parser-phase.cc	  -> [course dir]/src/PA3/parser-phase.cc
 stringtab.cc		  -> [course dir]/src/PA3/stringtab.cc
 tokens-lex.cc		  -> [course dir]/src/PA3/tokens-lex.cc
 tree.cc		  -> [course dir]/src/PA3/tree.cc
 utilities.cc		  -> [course dir]/src/PA3/utilities.cc
 *.d			  dependency files
 *.*			  other generated files

The include (.h) files for this assignment can be found in 
[course dir]/include/PA3

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.
    
	The README contains this info. Part of the assignment is to
	fill in the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and why
	your test cases are adequate. It is part of the assignment to
	clearly and concisely explain things in text as well as to comment
	your code. Just edit this file.

	cool.y is the skeleton for the parser specification that you
	are to write. It already contains productions for the program
	and the classes. Use them as an example to write the remaining
	productions.  You should also read the bison documentation.
	This skeleton will compile and run as is, but it doesn't
	do much.

	good.cl, bad.cl test a few features of the grammar. You should
	add tests to ensure that good.cl exercises every legal
	construction of the grammar and that bad.cl exercises as many
	different parsing errors as you can squeeze into one file.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).
	From this file, cool-tree.h and cool-tree.cc are automatically 
        generated by a utility that compiles the specification into
        C++ functions for producing and consuming the tree nodes.
        This file is provided for your reference.  DO NOT MODIFY.

        tree.{cc|h} contain definitions used by the tree package.
        cool-tree.handcode.h is the handwritten extension to
        cool-tree.h.  If you read cool-tree.h and cool-tree.cc, you will
        note that there are "hooks" for extending the classes
        declarations.  Extending and modifying the tree package is
        discussed in the "Cool Tour", but you do not need to (and should
        not) modify the tree package for this assignment.

	tokens-lex.cc is a lexer capable of reading a token stream from
	console in the format produced by the lexer phase. DO NOT
	MODIFY.

        parser-phase.cc contains a driver to test the parser. DO NOT
        MODIFY.

	dumptype.cc prints the AST out in a form readable by the
	semant phase of the compiler. DO NOT MODIFY.

	handle_flags.cc implements routines for parsing command line
        flags. DO NOT MODIFY.

        The rest of the files are created as byproducts of `bison'.
        `cool-parse.cc' is the generated C++ file containing the
        parser.

	Files not discussed are covered in the README for PA2.

Instructions
------------

	To compile your parser program type:

	% gmake parser

	This produces an executable named "parser" which is standalone
	phase of the Cool compiler.  It requires lexer, semant, and cgen
	to do anything useful.

	To test your parser on a file 'foo.cl' type

	% myparser foo.cl

	myparser is a shell script that "glues" together lexer and
	parser using pipes.

	To run your parser on the files good.cl and bad.cl type:

	% gmake dotest

	If you think your parser is correct and behaves like
	the one we wrote, you may want to run a COOL compiler using
	your parser:

	% mycoolc foo.cl

	To overwrite the default lexical analyzer with yours, replace 
	lexer (which is a symbolic link to the "official" lexer) with
        your lexer from PA2.

	To turnin your work type:

	% gmake submit-clean

	After running the above command, collect the files cool.y,
        good.cl, bad.cl, good.output, bad.output, and README into a
        package (.tar.gz or .zip) and submit the package in the moodle
        classpage. Don't forget to edit the README file to include your
        write-up, and to write your own test cases in good.cl and bad.cl.

 	You may turn in the assignment as many times as you like.
	However, only the last version will be retained for
	grading.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA3
----------------

Trabalho realizado por Vinicius Silva Gomes - 2021421869 para a
disciplina DCC053 - Compiladores I, no semestre 2023/1.


Para realizar a análise sintática de programas bem (ou mal) formados da
linguagem de programação COOL (Classroom Object-Oriented Language),
foi usado o Bison, que é um gerador de analisadores sintáticos para
linguagens de programação. O Bison fornece uma API que converte
anotações de gramáticas livres de contexto para reconhecedores LALR(1).

Dessa forma, as seções a seguir serão responsáveis por descrever como
a árvore sintática dos programas bem formados em COOL é feita através
do Bison, juntamente de como os erros apresentados na sintaxe podem
ser tratados.


Análisador Sintático para a linguagem COOL

A estratégia para produzir o analisador sintático foi bastante
simples, seguindo sempre as recomendações da maneira como o Bison
pede para que o arquivo seja formatado e escrito.

Sendo assim, o primeiro passo foi completar a lista dos não-terminais,
onde atribuíamos um tipo para o valor semântico de cada não-terminal. Ao
final, os tipos preenchidos foram: program, class, class list, feature,
feature list, formal, formal list, case, case list, expression,
expression list e, por fim, dispatch list.

Os tokens sem o sufixo "list" no final representam tokens que lidam
com apenas um tipo de construção específico:

* class: uma única classe da linaguagem;
* formal: um único parâmetro formal na chamada de método;
* case: um único "case" dentro do switch case branch;
* expression: uma única expressão da linguagem (é o mais abrangente
de todos).

As construções com o sufixo list são uma variação dessas acima,
com a adição de lidar com listas de classes, parâmetros formais,
expressões, etc.


Em seguida forma feitas as as definições de precedência da gramática.
As declarações foram que:

* "Less or Equal" (LE) e o operador de igualdade não possuem
associatividade a direita ou a esquerda;
* "NOT", "+", "-", "*", "/", "~", "ISVOID" possuem associatividade
a esquerda.


Por fim, definimos o comportamento para todos os tokens definidos,
informado o que é esperado e utilizando de variáveis e funções
auxiliares fornecidas pelo Bison para compor as expressões da forma
desejada. Após definir a sintaxe correta para cada tipo, podemos
também definir o token de erro e a condição em que ele aparece,
para que caso alguma expressão não esteja correta do ponto de vista
sintático, o mecanismo de error handling do Bison seja chamado e
o erro possa ser apontado ao programador.

As definições são relativamente simples, no sentido de que precisamos
apenas observar como as construções em COOL podem ser feitas e
mapear essa estrutura para a sintaxe do Bison, tomando os devidos
cuidados (por exemplo, podemos ter uma lista de features, ou seja,
métodos e atributos vazia, mas não podemos tem uma feature vazia
em uma lista).

Definida essa estrutura, o passo seguinte é testar exaustivamente
o analisador sintático e resolver os conflitos de shift/reduce e
reduce/reduce, principalmente, para remover a ambiguidade do parser
e gerar, com isso, resultados corretos. A maioria desses conflitos,
quando a construção estava correta, era resolvido mudando as
prioridades dentro da estrutura do Bison.

----------------

Com todas essas construções descritas, é possível, então, realizar a
análise sintática de programas COOL, tanto os bem construídos quanto
os mal construídos (retornam erros). Além disso, caso algum programa
esteja mal construído do ponto de vista sintático, o analisador será
capaz de identificar esses erros e retornar para o usuário qual o
erro ou construção incorreta foi identificado e em qual linha ele foi
identificado.

Além disso, para exercitar o analisador sintático construído, alguns
testes foram desenvolvidos para verificar que ele é capaz de gerar
as ASTs para os mais diversos, complexos e completos programas COOL da
maneira esperada, construindo corretamente a árvore quando a construção
é adequada, ou apresentando o devido erro, quando o programa não está
bem formulado.

Assim como pedido, além dos testes construídos para testar as mais
variadas situações durante o desenvolvimento do analisador, os programas
good.cl e bad.cl foram modificados para programas COOL com propósitos
de verificar casos onde o analisador sintático deve funcionar
corretamente e gerar a AST para o programa e casos onde o parser deve
ser capaz de perceber e retornar erros sintáticos que estão presentes 
no programa, respectivamente.

O programa good.cl, assim como para o PA2, é um exemplo fornecido de
como seria uma simulação do Jogo da Vida de Conway para alguns exemplos
de estados iniciais e quais seriam as futuras gerações para aquele estado.
Acredito que entre todos os exemplos fornecidos e os testes criados
durante o período de desenvolvimento do analisador, esse programa
é o maior, mais complexo e mais completo programa disponível.

Já o programa bad.cl não apresenta muita coisa em especial, se trata
apenas de um compilado de códigos com erros sintáticos, os quais tanto
o parser desenvolvido para esse PA quanto o parser oficial de COOL,
presente no compilador "coolc", são capazes de perceber os erros e
indicá-los ao programador.
